+++
date = '2025-12-14T00:39:34+08:00'
draft = false
weight = 5
title = '第四章_类的规范行为'
description = '笔记性质文章-承接【第三章】，重点讲述“类和类之间存在的关系” ， 构建【面向接口编程】'
+++
引言： 类和类之间的关系：抛去父子类表层，更多的是在本质上进行一种类对类的规范，实现规范的途径是：【抽象方法】 |
【抽象方法】的载体也就是模板类，即【抽象类】：【父类形式】/【接口形式】


# 类和类之间的规范行为
1. 【抽象类】/【接口】是模板 -> 其中【抽象方法】具体的模板条例
2. 来约定【子类】/【实现类】-> 的书写，所以【模板】完全服务于【子类】

### 抽象方法
是规定的【途径】
```java
    `abstract`修饰，无【方法体】
    【abstract】+【方法声明】;
    > 无法被调用，只能等【继承后重写】实现调用
    1. `abstract`与 `static`和`final` 的语义是冲突的，
    同时抽象方法一般不用`private`,必须用`public`保证【重写】来实现调用
    ------------------------------
    为什么【抽象方法】规范？规范了什么？
    -重写的语法：方法申明一致
```

### 抽象类
```java
    用`abstract`修饰 -> 增加 强限制：标注这个类是一个模板,强制子类的【重写】
    1. 有【抽象方法】一定是【抽象类】；【抽象类】不一定有【抽象方法】
    2. 【抽象类】无法实例化(*因为【抽象方法】的存在*),
        此时【构造器】存在意义是给子类调用
    3. 继承【抽象类】的【子类】必须是【抽象类】，或者重写所有【抽象方法】    
```

* 【抽象类】只是在正常父类基础上添加【抽象方法】这一禁制规定子类多态行为
* 而【接口】则是专精的【规范】，就是纯粹的规范【实现类】的多态行为
* 相似的类之间，本身有【父类】，那么就可以考虑父类增加【抽象方法】->【抽象类】来实现多态
* 非相关的类，但是行为呈现多态，可以用【接口】的【抽象类】规范
* 我们一般都是直接用【接口】做模板->面向接口编程，【抽象类】一般是临时起意
> class 【类】 extends 【父类】 implements 【接口1】,【接口2】,...{}

### 接口
```java
    是一种特殊的抽象类
    1. `interface 【接口】{}`创建 
        *接口的命名用 `I` 开头
    2. 在【接口】中没有常规的【类成员】，
        只有【抽象方法】(*默认前缀public abstract*)
        ->只需要设置【返回值】【方法名】【参数】
        /【可访问常量】(*默认前缀public static final*)
        ->只需要设置【数据类型】【属性名】   
    3. 【接口】无法实例化(*因为【抽象方法】的存在*),
        同时也没有构造器(*没有正常的类成员,无初始化逻辑*)
    4. 【接口】必须由【实现类】实现，以实现对其中的【抽象类】的调用        
```

### 继承与多态
* java的类的继承链，都是单链单继承，任何类都直接或者间接的继承[【Object】始祖类](#object始祖类)
* 【接口】可以同时多继承多个【接口】,本质上是【整合接口】的行为

* **多态**   
    1. 两种渠道：继承【抽象类】/实现【接口】-> 前提
    2. 必须有重写【抽象方法】-> 核心动作
    3. 【解耦合】<sup>父类引用指向子类对象</sup>的方式创建对象
```java
    # 向上转型 -> 本质上就是类型的自动转换
    父类 【对象名称1】 = new 子类( );
    > 出现弊端1：类型的动态，导致，【对象】是【子类类型】，但是成员丢失，
      只能访问从父类那继承的成员
    --------------------------------
    对象的类型是“动态的”-> 编译时| 是父类 -> 运行时| 是子类
    那我可以用`类A instanceof 类B` -> 判断类B是不是类A的祖先类
    --------------------------------
    【处理】弊端1
    -> 向下转型，本质是强制类型的强制转换
    子类 【对象名称2】= (子类) 对象名称1；
    此时，可以调用对象【对象1】的“子类特有的成员”了
    > 注意出现的情况：强制转换的【子类】如果与【对象1】的类型冲突，
      系统判定为[父类]->强制转换[子类]，在编译时不会报错
    * 保险的写法 ： 
    if(对象 instanceof 目标子类){
        向下转型
    }
```    

#### Object始祖类
* **始祖类的public方法 -> 所有类都会继承**
    > 不【重写】的话用的就是用原本方法
1. toString()方法 -- 设计对象的地址，返回String类型  
    `对象名.sout` -- 是默认`对象名.toString().sout`
2. equals()方法 -- 等价于`==`的判断,返回boolean值  
    `==`的判断* 基本数据类型，比较数值| 引用数据类型，比较地址|